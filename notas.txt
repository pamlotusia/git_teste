notas:

git init - pra inicar repositorio

git status - para veirificar mudan√ßas, o que estiver no git status √© o que nao est√° no servidor ainda

git add - para coloca-lo dentro do git e ele ser reconhecido 
git add . - coloca varios arquivos de uma vez sem que voc√™ tenha que nomea-los um por um

git commit - para salvar mudan√ßas
git commit -m    - a flag -m √© para nomear o commit, como uma boa pratica, √© uma mensagem
git commit -a    - a flag -a √© para salvar varios arquivos de uma vez sem que tenha que nomea-los um por um
 --√© possivel comitar arquivo sem salva-lo toda vez, desde que ele j√° tenha recebido um primeiro add, basta usar o comando acima

//trocando nome do arquivo por um mais semantico, mas esse comentario ser√° apagado
//quando voc√™ muda o nome do arquivo, ele passa a ser untracked, entao s√≥ tentar commitar sem dar add nao vai funcionar porque o git n√£o o reconhece
//dei commit antes de finalizar o comentario, bagun√ßou um pouco. mas em resumo, n√£o d√°, apenas com:
// git commit -a -m , do contrario tem que fazer o add

git push - para enviar finalmente o c√≥digo para o repositorio remoto, at√© ent√£o ele estava salvo, mas n√£o tinha sido enviado ainda 

git pull - recebe arquivos do repositorio remoto para sua maquina, ou seja , o que est√° salvo no github (por exemplo) passa a estar no seu computador. Assim voc√™ tem a vers√£o mais atualizada do c√≥digo do projeto (sabendo que geralmente tem v√°rias pessoas envolvidas na constru√ß√£o do projeto). N√£o √© necess√°rio fazer mais nenhum comando, apenas o git pull faz tudo o que √© preciso
//Portanto, git push envia, git pull recebe.

git clone - para iniciar um repositorio de um projeto novo j√° em andamento por outras pessoas, precisamos clonar ele. Nao usamos git init, porque √© um repositorio j√° existente, o que fazemos √© nos juntarmos ao time clonando e referenciando o repositorio com git clone. O comando vai literalmente clonar o repositorio pra sua maquina, de forma que as proximas altera√ß√µes que voce fizer j√° estar√£o referenciadas √†quele endere√ßo
// git clone [endere√ßo url]
//n√£o entendi muito bem, deu erro aqui na hora de trocar de pastas pelo terminal usando o comando cd, depois na hora de clonar, clonou as pastas de um jeito estranho. Eu n√£o esperava que a pasta "primeiro_repo" fosse clonada nessa hierarquia, achei que somente os arquivos dela viriam pra mim
//e mais, agora quando vou dar push aparece:
// git remote add <name> <url>

//and then push using the remote name

//   git push <name>
//nao sei porqu√™, mas sei que se eu seguir as instru√ß√µes funciona. Por√©m n√£o parece 100% certo, devo ter perdido alguma coisa pelo caminho
//bom, nada funcionou, tive que excluir a pasta principal do computador e s√≥ dai clonar o repositorio na maquina, acredito que o problema
//tenha sido exatamente esse, navegar entre as pastas. Quando clonei, fiz isso na pasta generica "Downloads" do pc, nem mesmo abri uma pasta
//"curso_git" porque estava dando problema. Aparentemente deu certo, espero n√£o ter que lidar com isso de novo, fiz os testes com git status
//e git remote -v, agora o endere√ßo aparece certinho. Ah, outra coisa, antes de aagar tudo, os testes com git remote -v retornavam vazio, 
//como se nao tivesse endere√ßo nem nada, mas quando eu tentei fazer alguns push seguindo as instru√ß√µes dava que o nome j√° existia, acho que
//s√≥ d√° pra fazer uma vez. Enfim, uma merda.

git rm - para remover arquivo ou pasta, basta usar o comando e o nome do arquivo, depois realizar o commit e o push normalmente

git log - para verificar os commits feitos (um breve resumo, s√≥ o titulo do commit, data e autor)
//d√° pra verificar as altera√ß√µes desde o primeiro commit, mesmo que o meu repositorio local seja um clone, que legal. Eu achei que n√£o dava porque eu tive que clonar pra resolver o problema e o historico n√£o estava aparecendo por completo, mas eu tava usando o scroll do mouse, n√£o a setinha do teclado, por isso n√£o descia. Adorei essa info, amei mesmo.

git mv - para renomear ou alterar localiza√ß√£o entre as pastas sem perder a referencia com o git. Ele exclui o arquivo anterior e cria um novo. √© necess√°rio realizar commit e push para finalizar a altera√ß√£o.
--git mv <nome_atual_do_arquivo> <nome_que_√©_pra_ser_ou_endere√ßo_completo_que_√©_para_estar>
//um detalhe, √© preciso respeitar a hierarquia de pastas, entao se o arquivo vai para uma pasta que est√° dentro de outra pasta (uma pasta m√£e, por assim dizer)
//voc√™ precisa declarar as duas na linha de comando, pra que seja efetuado corretamente, do contrario a localiza√ß√£o n√£o vai ser encontrada

git checkout - retorna ao estado original, que √© o estado que est√° no repositorio remoto
-- git checkout <nome_completo_do_arquivo>
//se voc√™ fizer uma altera√ß√£o no arquivo e se arrependeu, mas apagar at√© deixar e-xa-ta-men-te igual ao que est√° no repositorio, n√£o precisa usar o git checkou, voc√™ vai conferir com git status e perceber que ele n√£o identificou nehuma altera√ß√£o.
//por√©m fazer na m√£o n√£o √© uma boa pr√°tica porque sai errado, ent√£o usamos o git checkout pra voltarmos ao estado inicial(ultimo endpoint do repositorio remoto)
//esse comando apaga automaticamente as altera√ß√µes do arquivo, por isso, CUIDADO. Voc√™ pode acabar perdendo todo o seu trabalho
//agora um teste, vamos ver se o git checkout apaga desde o commit ou s√≥ arquivos nao commitados, ou seja, salvos ainda
//naaaaao, ele volta apenas ao momento em que voc√™ n√£o fez o commit ainda. Depois de feito o commit, voc√™ vai precisar de outra forma para cancelar ou apagar ele.
//eu escrevi a frase e dei commit, logo em seguida dei checkout e ele n√£o apagou minha frase, dei push e meu commit subiu ü•¥. Ou seja, o checkout s√≥ apaga se as altera√ß√µes n√£o estiverem sido commitadas.

.gitignore - arquivo criado na raiz do projeto e nele inserimos os arquivos que n√£o devem entrar no versionamento(ou seja, subir para o repositorio remoto)
//isso √© muito util para arquivos gerados automaticamente ou com informa√ß√µes sens√≠veis (.venv √© um exemplo que eu j√° vi (√© um ambiente virtual))
//obs: primeiro criar arquivo .gitignore e declarar o nome dos arquivos e pastas que dever√£o ser ignorados, DEPOIS criar essas pastas no repositorio local, area de trabalho e afins.
//importante, o arquivo .gitignore vai subir para o repositorio remoto, mas os arquivos declarados nele n√£o, essa √© a magia da coisa

git reset - reseta o codigo a partir do ultimo endpoint do repositorio remoto, incluindo os commits que foram feitos. Ou seja, ele apaga tudo mesmo üò±üò±üò±
// git reset --hard origin/main: a flag --hard for√ßa esse reset e o origin/main √© o repositorio que voc√™ quer parear (algo assim, nao entendi 100%, mas gostei)

git branch - verificar os branches existentes

git branch <nome_novo_branch> - cria novo branch. Apenas criar novos branches a partir da branch master, porque as outras branches s√£o usadas pra teste. Logo, se voc√™ criar um novo ambiente de uma branch que n√£o seja a master, vai estar carregando codigo n√£o testado, o que √© uma pessima pratica porque agrava os problemas e a manuten√ß√£o.

git branch -D (para branches locais) ou git branch --delete   - as flags -d ou --delete deletam branches, o que n√£o √© muito comum, geralmente se mant√©m para nao perder o historico. Ent√£o cuidado ao apagar branches. No mais, s√≥ apagamos branches se ela foi criado errado (n√£o cumpre o padr√£o da cria√ß√£o que foi estabelecido etc etc).
git push origin --delete <nome_da_branch>(para branches remotas)

git checkout <nome_da_branch> - esse comando muda de branch.
--git checkout -b <nome_da_branch> - a flag -b tambem cria ao mesmo tempo que muda (se o branch j√° nao tiver sido criado)
//üö®üß®üí£CUIDADO AO MUDAR DE BRANCH SEM DAR COMMIT ANTES, PODE DAR MUITO TIRO PORRADA E BOMBAüí£üß®üö®

git merge - une branches, por√©m √© incomum no mercado de trabalho que 'Voc√™' una a sua branch de trabalho com a branch principal, outras pessoas fazem isso, por outros meios, para garantir que o codigo que vai subir esteja aprovado coisa e tal. Tudo para garantir que a produ√ß√£o n√£o fique comprometida.
--git merge <nome_do_arquivo_que_a_branch_atual_vai_receber> - se usa assim, voc√™ EST√Å na branch que vai receber o codigo, ou seja, o codigo declarado no comando e o que vai entrar :D 

git push <remote> --delete <nome_do_branch>  - para excluir branch REMOTO 
--git push origin --delete segundo_branch  - por exemplo

git stash - uma especie de lixeira, jeito de jogar fora, mas que d√° pra recuperar depois
//as stashes s√£o uteis quando voc√™ est√° trabalhando em uma solu√ß√£o que ainda nao est√° boa e voc√™ quer iniciar do zero, mas sem perder o seu progresso, sobrescrever ou perder suas ideias. Quando voc√™ quer salvar em algum lugar e revisitar depois voc√™ usa o comando git stash.
//Dessa forma, seu codigo volta ao estado do ultimo push, mas aqueles codigos estar√£o salvos na lista de stashes

git stash list - lista as stashes mostrando as vers√µes

git stash apply (numero_da_stash) - as stashes s√£o ordenadas em numeros, usando o comando git stash list √© capaz de verificar isso, entao quando for verificar os codigos da stash, basta chamar com o codigo acima da seguinte forma por exemplo:
//git stash apply 0

git tag -a <nome_da_tag> -m "<msg>"- dessa forma criamos tags, que s√£o checkpoints do nosso codigo, quase uma branch do branch
//√â utilizada para demarcar estagios do desenvolvimento de algum recurso
//antes de criar a tag √© necessario commitar, dai ela vai salvar as altera√ß√µes do ultimo commit at√© o momento do commit atual.

git show <nome> - mostra em detalhes o conteudo da tag

git checkout <nome> - podemos trocar entre as tags usando esse comando

git push origin <nome> - podemos usar esse comando para enviar tags ao repositorio remoto. Dessa forma declaramos uma tag especifica e ela √© enviada.

git push origin --tags  - ou podemos enviar todas as tags que temos de uma vez.

git push --delete origin <nome_da_tag> - deleta tag no repo remoto 
//Aparentemente tem que declarar uma a uma, n√£o funciona usando --tags pra deletar todas de uma vez
git tag -d <nome_da_tag> - deleta tag no repo local 

git fetch - voc√™ √© atualizado de todos os branches e tags n√£o reconhecidos por voce, √© como um pull de branches
//seu amigo abriu uma nova branch e agora voc√™ precisa acessar ela, mas ela ainda n√£o est√° mapeada no seu terminal local, ent√£o o git fetch
//tr√°s essa nova branch pra voc√™ conseguir acess√°-la

git show - d√° informa√ß√µes da branch atual e tamb√©m dos seus commits. as modifica√ß√µes entre cada arquivo tamb√©m s√£o exibidas
//podemos exibir informa√ß√µes de tags tambem com o comando:
git show <tag>

git diff - mostra as diferen√ßas de um branch, ele aceita altera√ß√µes commitadas e nao commitadas, √© justamente para comparar branch remoto com atual,de forma que se voc√™ fizer altera√ß√µes e der push, elas nao v√£o ser sinalizadas no terminal, porque essa √© a nova vers√£o do repo remoto. quando utilizado as diferen√ßas do branch atual com o remoto ser√£o exibidas no terminal
//podemos verificar tamb√©m a diferen√ßas entre arquivos: git diff <arquivo> <arquivo_b>
//na compara√ß√£o de branches, n√£o √© preciso declarar as duas da seguinte forma:
// ‚ùå git diff <branch1> <branch2> - porque ele j√° est√° 'pegando' a branch atual como a 'branch1'. O sistema j√° faz isso pra voce
//ent√£o, quando for comparar branches, fa√ßa assim:
// ‚úÖ git diff <branch2> - a branch2 √© a branch que voc√™ vai comparar com a branch atual.

git shortlog - resumo dos logs do projeto. cada commit ser√° unido pelo nome do autor, podemos entao saber qual commit foi enviado e por quem"

git clean - limpa os arquivos untracked do repositorio local, usado por exemplo para arquivos que s√£o gerados automatimamente ou que foram baixados errado
//git clean -f   - para for√ßar o comando, caso o terminal de controle reclame de alguma coisa

git gc - abrevia√ß√£o de garbage collector. identifica quais arquivos n√£o s√£o mais necessarios e os exclui. Isso otimizar√° a performance do repositorio, porque ele ter√° menos tarefas para executar (tirando o lixo fora). √© boa pr√°tic afazer de tempos em tempos e em projetos grandes.

git fsck - abrevia√ß√£o de File System Check. usado para verificar a integridade dos arquivos e sua conectividade. comando de rotina pra saber se est√° tudo nos conformes. 

git reflog - mapea todos os seus passos dentro do repositorio, at√© mudan√ßa de branch √© inserida nesse relatorio do reflog.
por ser um relatorio detalhado, ele tem prazo de expira√ß√£o, o padr√£o s√£o 30 dias, mas isso √© configur√°vel. 

git reset --hard <endere√ßo do commit/altera√ßao> - reseta ao estado daquele commit, por exemplo

git archive --format zip --output <nome_da_pasta>.zip <nome_da_branch>  - esse comando zipa o repositorio local, o projeto. √â usado quando estamos codando apenas em ambiente remoto e n√£o temos como zipar usando a interface do computador como fariamos normalmente, √© uma op√ß√£o :D

‚ùó‚ùó‚ùóAten√ß√£o, tutorial de como usar private branches a seguir, assunto level 2 de complexidade, mantenha  a calma que tudo vai dar certo‚ùó‚ùó‚ùó
üìåPor que usar private branch? Para termos uma area livre de trabalho, onde podemos escrever nossos commits livremente, sem atrapalhar os logs oficiais da empresa, prejudicando o entendimento da equipe sobre o projeto, fun√ß√£o e afins. 
üë©üèΩ‚Äçüöí Certo, como fazer ent√£o?
Uma private branch √© basicamente uma branch normal (ou seja, n√£o precisa de nenhum comando especial pra se abrir) que voc√™ define um nome diferente, voc√™ vai us√°-la como playground e s√≥ depois enviar√° os codigos e commits pra branch oficial.
Ao final da solu√ß√£o do problema, podemos fazer um rebase, que √© o comando estrela desse show
//git rebase <atual> <branch_teste> -i  -- a flag -i que vai permitir intera√ß√£o com os commits no terminal 
Bom, com a extens√£o do GitLens fica mais f√°cil eliminar ou editar commits, a tela √© bem intuitiva, ao finalizar as edi√ß√µes, basta clicar no icone ‚úî ou algo parecido com esse que o commit ser√° aprovado
para comentar alguma coisa, basta colocar # antes da mensagem, assim ela ser√° ignorada
Pick significa 'levar' ou seguir adiante com aquele commit
Squash significa deletar
Reword √© renomear commit
O comando git rebase √© responsavel por trazer o conteudo de uma branch ativa para outra, ent√£o fazemos todo esse trabalho com os commits para que o ambiente de trabalho fique organizado e semantico. Mas se voc√™ quiser fazer commits semanticos desde o inicio, sem a necessidade de abrir private branches, tamb√©m pode, fique a vontade üë©üèΩ‚ÄçüöíüëçüèΩ
‚úÖAssim finalizamos o assunto de private branch (que √© uma boa pr√°tica, uma cultura), como fazer e usar

üå∏Boas pr√°ticas dos commitsüå∏
  * Separar assunto do corpo da mensagem
  * Assunto com no m√°ximo 50 caracteres (para que fique visivel na tela sem cortar nenhuma palavra da mensagem)
  * Assunto com letra inicial maiuscula
  * Corpo com no m√°ximo 72 caracteres
  * Explicar o porqu√™ e como da solu√ß√£o de forma breve, de forma que descreva sem ficar se repetindo. O c√≥digo j√° est√° ali, voc√™ n√£o precisa reescrev√™-lo no commit üòâ